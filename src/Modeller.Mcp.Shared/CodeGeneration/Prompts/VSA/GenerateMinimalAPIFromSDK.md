# Generate Minimal API from SDK and Domain Models - Vertical Slice Architecture

## Purpose

Generate a complete .NET Minimal API project from an existing SDK and domain model YAML definitions. The API project should showcase integration with the SDK, following Vertical Slice Architecture (VSA) and modern .NET best practices.

## Context

You are an expert .NET API developer specializing in Minimal APIs, Vertical Slice Architecture (VSA), and clean integration patterns. You will generate a production-ready Minimal API project that properly integrates with a generated SDK and implements all domain behaviors.

## Input Requirements

- **Generated SDK Path**: Path to the existing SDK project generated from domain models
- **Domain Model YAML**: Complete YAML definitions of domain entities (Type and Behaviour)
- **Project Name**: The name of the API project (e.g., "Business.CustomerManagement.Api")
- **Namespace**: Target namespace for the API (e.g., "Business.CustomerManagement.Api")
- **Output Path**: Directory where the API project will be generated

## Architecture Principles

- **Minimal APIs**: Use .NET Minimal APIs instead of traditional controllers
- **Vertical Slice Architecture**: Organize by feature, not technical layer
- **SDK Integration**: Leverage the generated SDK for models, validation, and business logic
- **Clean Architecture**: Separate concerns while maintaining simplicity
- **Domain-Driven Design**: Implement business behaviors from YAML definitions
- **Modern Patterns**: Result pattern, dependency injection, async/await throughout

## Framework Requirements

- **Target Framework**: .NET 8.0 LTS (Latest Long Term Support version)
- **C# Language Version**: C# 12 or latest available for .NET 8
- **Nullable Reference Types**: Enabled for enhanced type safety
- **ImplicitUsings**: Enabled to work with GlobalUsings pattern
- **Documentation Generation**: Enable XML documentation and OpenAPI/Swagger

## Project Configuration

Generate a `.csproj` file with the following specifications:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <LangVersion>12</LangVersion>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <WarningsAsErrors />
    <WarningsNotAsErrors>CS1591</WarningsNotAsErrors>
    <Title>Business Domain API</Title>
    <Description>Production-ready Minimal API generated from domain models</Description>
    <Version>1.0.0</Version>
    <Authors>Generated by Modeller MCP</Authors>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="8.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="FluentValidation.AspNetCore" Version="11.3.0" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Diagnostics.HealthChecks" Version="2.2.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\{SdkProjectName}\{SdkProjectName}.csproj" />
  </ItemGroup>
</Project>
```

## GlobalUsings Configuration

Create a `GlobalUsings.cs` file at the project root:

```csharp
// GlobalUsings.cs - API Project
global using System;
global using System.Collections.Generic;
global using System.ComponentModel.DataAnnotations;
global using System.Linq;
global using System.Threading;
global using System.Threading.Tasks;
global using Microsoft.AspNetCore.Mvc;
global using Microsoft.EntityFrameworkCore;
global using FluentValidation;
global using FluentValidation.Results;
// Import the SDK namespace
global using {SdkNamespace};
global using {SdkNamespace}.Common;
```

## Generated Structure

```text
{ProjectName}/
├── {ProjectName}.csproj                 # Project configuration
├── Program.cs                           # Application entry point
├── GlobalUsings.cs                      # Common using statements
├── appsettings.json                     # Configuration
├── appsettings.Development.json         # Development configuration
├── Data/
│   ├── {ProjectName}DbContext.cs        # Entity Framework DbContext
│   └── SeedData.cs                      # Database seeding
├── Extensions/
│   ├── ServiceCollectionExtensions.cs  # DI configuration
│   └── WebApplicationExtensions.cs     # Middleware configuration
├── Services/
│   ├── {Entity}Service.cs               # Business logic services
│   └── I{Entity}Service.cs              # Service interfaces
├── Endpoints/
│   └── {Entity}Endpoints.cs             # Minimal API endpoints
├── Middleware/
│   ├── ErrorHandlingMiddleware.cs       # Global error handling
│   └── ValidationMiddleware.cs          # Request validation
└── Models/
    └── ApiModels.cs                     # API-specific models
```

## Code Generation Guidelines

### 1. Program.cs - Application Bootstrap

```csharp
using {ProjectName}.Data;
using {ProjectName}.Extensions;

var builder = WebApplication.CreateBuilder(args);

// Configure services
builder.Services.AddApiServices(builder.Configuration);

var app = builder.Build();

// Configure pipeline
app.ConfigureApiPipeline();

// Map endpoints
app.MapApiEndpoints();

// Seed database
app.SeedDatabase();

app.Run();
```

### 2. DbContext Implementation

```csharp
using Microsoft.EntityFrameworkCore;
using {SdkNamespace}.{FeatureName};

namespace {ProjectName}.Data;

/// <summary>
/// Entity Framework DbContext for the {ProjectName}
/// </summary>
public class {ProjectName}DbContext : DbContext
{
    public {ProjectName}DbContext(DbContextOptions<{ProjectName}DbContext> options) : base(options) { }

    // DbSets for each domain entity
    public DbSet<{Entity}> {Entities} { get; set; } = null!;

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        
        // Configure entities based on domain model constraints
        // Apply YAML-defined relationships and constraints
        // Configure primary keys as Version 7 UUIDs
        
        modelBuilder.Entity<{Entity}>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Id).ValueGeneratedNever(); // UUID v7 generated client-side
            
            // Configure properties based on YAML definitions
            // Apply constraints, relationships, and business rules
        });
    }
}
```

### 3. Service Layer Implementation

```csharp
using {ProjectName}.Data;
using {SdkNamespace}.{FeatureName};
using {SdkNamespace}.Common;

namespace {ProjectName}.Services;

/// <summary>
/// Service interface for {Entity} operations
/// </summary>
public interface I{Entity}Service
{
    Task<ApiResult<{Entity}Response>> CreateAsync(Create{Entity}Request request, CancellationToken cancellationToken = default);
    Task<ApiResult<{Entity}Response>> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);
    Task<ApiResult<IEnumerable<{Entity}Response>>> GetAllAsync(CancellationToken cancellationToken = default);
    Task<ApiResult<{Entity}Response>> UpdateAsync(Guid id, Update{Entity}Request request, CancellationToken cancellationToken = default);
    Task<ApiResult<bool>> DeleteAsync(Guid id, CancellationToken cancellationToken = default);
}

/// <summary>
/// Service implementation for {Entity} business operations
/// </summary>
public class {Entity}Service : I{Entity}Service
{
    private readonly {ProjectName}DbContext _context;
    private readonly IValidator<Create{Entity}Request> _createValidator;
    private readonly IValidator<Update{Entity}Request> _updateValidator;
    private readonly ILogger<{Entity}Service> _logger;

    public {Entity}Service(
        {ProjectName}DbContext context,
        IValidator<Create{Entity}Request> createValidator,
        IValidator<Update{Entity}Request> updateValidator,
        ILogger<{Entity}Service> logger)
    {
        _context = context;
        _createValidator = createValidator;
        _updateValidator = updateValidator;
        _logger = logger;
    }

    public async Task<ApiResult<{Entity}Response>> CreateAsync(Create{Entity}Request request, CancellationToken cancellationToken = default)
    {
        // 1. Validate input using SDK validator
        var validationResult = await _createValidator.ValidateAsync(request, cancellationToken);
        if (!validationResult.IsValid)
            return ApiResult<{Entity}Response>.ValidationFailure(validationResult.ToErrorMessages());

        // 2. Map to entity using SDK extensions
        var entity = request.ToEntity();
        entity.Id = Guid.CreateVersion7(); // Generate Version 7 UUID
        entity.CreatedAt = DateTime.UtcNow;
        entity.CreatedBy = "system"; // TODO: Get from current user context

        // 3. Persist to database
        _context.{Entities}.Add(entity);
        await _context.SaveChangesAsync(cancellationToken);

        // 4. Return response using SDK extensions
        var response = entity.ToResponse();
        return ApiResult<{Entity}Response>.Success(response);
    }

    // Implement other CRUD operations following similar patterns
    // Include business logic from YAML behavior definitions
}
```

### 4. Minimal API Endpoints

```csharp
using {ProjectName}.Services;
using {SdkNamespace}.{FeatureName};
using Microsoft.AspNetCore.Http.HttpResults;

namespace {ProjectName}.Endpoints;

/// <summary>
/// Minimal API endpoints for {Entity} operations
/// </summary>
public static class {Entity}Endpoints
{
    public static void Map{Entity}Endpoints(this WebApplication app)
    {
        var group = app.MapGroup("/{entities}")
            .WithTags("{Entity}")
            .WithOpenApi();

        // GET /{entities} - List all entities
        group.MapGet("/", GetAll{Entities})
            .WithName("GetAll{Entities}")
            .WithSummary("Get all {entities}")
            .Produces<IEnumerable<{Entity}Response>>(200)
            .Produces<ProblemDetails>(400);

        // GET /{entities}/{id} - Get entity by ID
        group.MapGet("/{id:guid}", Get{Entity}ById)
            .WithName("Get{Entity}ById")
            .WithSummary("Get {entity} by ID")
            .Produces<{Entity}Response>(200)
            .Produces<ProblemDetails>(404);

        // POST /{entities} - Create new entity
        group.MapPost("/", Create{Entity})
            .WithName("Create{Entity}")
            .WithSummary("Create a new {entity}")
            .Produces<{Entity}Response>(201)
            .Produces<ValidationProblemDetails>(400);

        // PUT /{entities}/{id} - Update entity
        group.MapPut("/{id:guid}", Update{Entity})
            .WithName("Update{Entity}")
            .WithSummary("Update an existing {entity}")
            .Produces<{Entity}Response>(200)
            .Produces<ValidationProblemDetails>(400)
            .Produces<ProblemDetails>(404);

        // DELETE /{entities}/{id} - Delete entity
        group.MapDelete("/{id:guid}", Delete{Entity})
            .WithName("Delete{Entity}")
            .WithSummary("Delete a {entity}")
            .Produces(204)
            .Produces<ProblemDetails>(404);

        // Add business operation endpoints based on YAML behavior definitions
    }

    private static async Task<Results<Ok<IEnumerable<{Entity}Response>>, BadRequest<ProblemDetails>>> GetAll{Entities}(
        I{Entity}Service service,
        CancellationToken cancellationToken)
    {
        var result = await service.GetAllAsync(cancellationToken);
        return result.IsSuccess 
            ? TypedResults.Ok(result.Data!)
            : TypedResults.BadRequest(new ProblemDetails { Detail = result.ErrorMessage });
    }

    private static async Task<Results<Ok<{Entity}Response>, NotFound<ProblemDetails>>> Get{Entity}ById(
        Guid id,
        I{Entity}Service service,
        CancellationToken cancellationToken)
    {
        var result = await service.GetByIdAsync(id, cancellationToken);
        return result.IsSuccess
            ? TypedResults.Ok(result.Data!)
            : TypedResults.NotFound(new ProblemDetails { Detail = result.ErrorMessage });
    }

    private static async Task<Results<Created<{Entity}Response>, ValidationProblem>> Create{Entity}(
        Create{Entity}Request request,
        I{Entity}Service service,
        CancellationToken cancellationToken)
    {
        var result = await service.CreateAsync(request, cancellationToken);
        if (!result.IsSuccess)
        {
            return TypedResults.ValidationProblem(new Dictionary<string, string[]>
            {
                ["request"] = result.ValidationErrors?.ToArray() ?? ["Validation failed"]
            });
        }

        return TypedResults.Created($"/{entities}/{result.Data!.Id}", result.Data);
    }

    // Implement other endpoint handlers following similar patterns
}
```

### 5. Dependency Injection Configuration

```csharp
using {ProjectName}.Data;
using {ProjectName}.Services;
using {ProjectName}.Middleware;
using {SdkNamespace}.{FeatureName};

namespace {ProjectName}.Extensions;

/// <summary>
/// Service collection extensions for dependency injection
/// </summary>
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddApiServices(this IServiceCollection services, IConfiguration configuration)
    {
        // Entity Framework
        services.AddDbContext<{ProjectName}DbContext>(options =>
            options.UseInMemoryDatabase("{ProjectName}"));

        // SDK Validators
        services.AddScoped<IValidator<Create{Entity}Request>, Create{Entity}Validator>();
        services.AddScoped<IValidator<Update{Entity}Request>, Update{Entity}Validator>();

        // Business Services
        services.AddScoped<I{Entity}Service, {Entity}Service>();

        // API Documentation
        services.AddEndpointsApiExplorer();
        services.AddSwaggerGen(c =>
        {
            c.SwaggerDoc("v1", new() { Title = "{ProjectName}", Version = "v1" });
            c.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, "{ProjectName}.xml"));
        });

        // Health Checks
        services.AddHealthChecks()
            .AddDbContextCheck<{ProjectName}DbContext>();

        // Logging
        services.AddLogging();

        return services;
    }
}
```

### 6. Middleware Configuration

```csharp
namespace {ProjectName}.Extensions;

/// <summary>
/// Web application extensions for middleware configuration
/// </summary>
public static class WebApplicationExtensions
{
    public static WebApplication ConfigureApiPipeline(this WebApplication app)
    {
        // Development tools
        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }

        // Security
        app.UseHttpsRedirection();

        // Error handling
        app.UseMiddleware<ErrorHandlingMiddleware>();

        // Health checks
        app.MapHealthChecks("/health");

        return app;
    }

    public static WebApplication MapApiEndpoints(this WebApplication app)
    {
        // Map all entity endpoints
        app.Map{Entity}Endpoints();
        
        return app;
    }

    public static WebApplication SeedDatabase(this WebApplication app)
    {
        using var scope = app.Services.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<{ProjectName}DbContext>();
        
        // Ensure database is created
        context.Database.EnsureCreated();
        
        // Seed with test data based on domain models
        SeedData.Seed(context);
        
        return app;
    }
}
```

## YAML Integration Guidelines

### Domain Entity Mapping
- Map each YAML Type definition to an Entity Framework entity
- Implement all YAML-defined attributes as entity properties
- Apply YAML constraints as EF configurations and validations

### Behavior Implementation
- Convert YAML Behaviour definitions to service methods
- Implement business logic as described in YAML summaries
- Create corresponding API endpoints for each behavior

### Constraint Application
- Apply YAML `required` constraints as non-nullable properties
- Implement `maxLength` as EF string length configurations
- Use YAML `pattern` constraints in validators
- Convert YAML enums to C# enums and EF value converters

### Relationship Mapping
- Implement YAML-defined relationships as EF navigation properties
- Configure foreign keys based on YAML relationship definitions
- Apply cascade delete rules as specified in domain models

## Security Considerations

- **Input Validation**: Use SDK validators for all inputs
- **Authorization**: Implement proper authorization patterns (add when required)
- **Error Handling**: Sanitize error responses to prevent information leakage
- **Logging**: Log all operations with audit trails
- **UUID Version 7**: Use Version 7 UUIDs for all primary keys for optimal performance
- **SQL Injection Prevention**: Use Entity Framework parameterized queries
- **Rate Limiting**: Consider adding rate limiting for production deployments

## Output Format

Provide complete, compilable C# files for a production-ready Minimal API project:

- **Project File**: `.csproj` with all necessary dependencies and SDK reference
- **Application Bootstrap**: Complete `Program.cs` with proper configuration
- **GlobalUsings**: Common namespaces including SDK imports
- **Data Layer**: Entity Framework DbContext with proper entity configurations
- **Service Layer**: Business logic services implementing domain behaviors
- **API Layer**: Minimal API endpoints with OpenAPI documentation
- **Middleware**: Error handling and validation middleware
- **Configuration**: Service registration and pipeline configuration
- **Seed Data**: Realistic test data based on domain models

### Required Files per Project

1. **{ProjectName}.csproj** - Project configuration with SDK reference
2. **Program.cs** - Application entry point and configuration
3. **GlobalUsings.cs** - Common namespace imports including SDK
4. **Data/{ProjectName}DbContext.cs** - Entity Framework context
5. **Data/SeedData.cs** - Database seeding with test data
6. **Services/I{Entity}Service.cs** - Service interfaces for each entity
7. **Services/{Entity}Service.cs** - Service implementations for each entity
8. **Endpoints/{Entity}Endpoints.cs** - Minimal API endpoints for each entity
9. **Extensions/ServiceCollectionExtensions.cs** - DI configuration
10. **Extensions/WebApplicationExtensions.cs** - Middleware and endpoint configuration
11. **Middleware/ErrorHandlingMiddleware.cs** - Global error handling
12. **appsettings.json** and **appsettings.Development.json** - Configuration files

## Integration Showcase

The generated API project should demonstrate:
- **Complete SDK Integration**: Proper use of SDK models, validators, and extensions
- **Domain Behavior Implementation**: All YAML-defined behaviors as API operations
- **Modern API Patterns**: Minimal APIs, result patterns, proper HTTP status codes
- **Production Ready**: Error handling, logging, health checks, documentation
- **VSA Architecture**: Feature-based organization following VSA principles

## Usage

This prompt template will be used with the Modeller MCP secure prompt building system to generate production-ready Minimal API projects that showcase proper integration with generated SDKs and implement all domain model behaviors.
