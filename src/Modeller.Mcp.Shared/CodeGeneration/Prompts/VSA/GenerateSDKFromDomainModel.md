# Generate SDK from Domain Model - Vertical Slice Architecture

## Purpose

Generate a clean .NET SDK class library with feature-based vertical slices from
Modeller domain model YAML definitions. Each feature maintains all related
components (requests, responses, validators, extensions) in a single folder
structure.

## Context

You are an expert .NET developer specializing in Vertical Slice Architecture
(VSA) and clean code generation. You will generate production-ready C# code
from YAML domain models that follows modern .NET best practices.

## Input Requirements

- **Domain Model YAML**: Complete YAML definition of a domain entity (Type or
  Behaviour)
- **Feature Name**: The name of the feature/entity (e.g., "Customers",
  "Orders")
- **Namespace**: Target namespace for the SDK (e.g., "Business.CustomerManagement.Sdk")

## Architecture Principles

- **Vertical Slice Architecture**: Each feature contains all related components
- **Record Types**: Use C# records for immutable request/response models
- **FluentValidation**: Single validation approach for consistency
- **Extension Methods**: Clean mapping without AutoMapper complexity
- **Result Pattern**: Success/failure return types
- **Feature Folders**: Group by business capability, not technical layer
- **GlobalUsings**: Centralize common using statements to reduce boilerplate

## Framework Requirements

- **Target Framework**: .NET 8.0 LTS (Latest Long Term Support version)
- **C# Language Version**: C# 12 or latest available for .NET 8
- **Nullable Reference Types**: Enabled for enhanced type safety
- **ImplicitUsings**: Enabled to work with GlobalUsings pattern
- **Documentation Generation**: Enable XML documentation file generation

## Project Configuration

Generate a `.csproj` file with the following specifications:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <LangVersion>12</LangVersion>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <WarningsAsErrors />
    <WarningsNotAsErrors>CS1591</WarningsNotAsErrors>
    <Title>Business Domain SDK</Title>
    <Description>Production-ready SDK generated from domain models</Description>
    <Version>1.0.0</Version>
    <Authors>Generated by Modeller MCP</Authors>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="FluentValidation" Version="11.8.1" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="8.0.0" />
  </ItemGroup>
</Project>
```

## GlobalUsings Configuration

Create a `GlobalUsings.cs` file at the project root to include commonly used namespaces across all files:

```csharp
// GlobalUsings.cs
global using System;
global using System.Collections.Generic;
global using System.ComponentModel.DataAnnotations;
global using System.Linq;
global using System.Threading;
global using System.Threading.Tasks;
// Note: FluentValidation not included globally due to ValidationResult ambiguity
// Include FluentValidation only in validator files
```

This approach eliminates the need to include these using statements in every file, significantly reducing code duplication and maintenance overhead.

### File-Level Using Guidelines

After implementing GlobalUsings, files should only include:

- **Namespace-specific imports**: Only the project's own namespaces (e.g., `using Business.CustomerManagement.Sdk.Common;`)
- **Specialized imports**: Libraries with potential conflicts (e.g., `FluentValidation`, `FluentValidation.Results`)
- **Framework-specific imports**: Specialized System namespaces not commonly used (e.g., `System.Text.Json`)

### Important Notes

- **FluentValidation Conflict**: Do not include `FluentValidation` in GlobalUsings due to `ValidationResult` type conflicts with `System.ComponentModel.DataAnnotations.ValidationResult`
- **Explicit Types**: Use fully qualified type names when conflicts arise (e.g., `FluentValidation.Results.ValidationResult`)
- **Validator Files**: Include `using FluentValidation;` and `using FluentValidation.Results;` only in validator files
- **ValidationExtensions Files**: Use type alias to resolve ValidationResult ambiguity: `using ValidationResult = FluentValidation.Results.ValidationResult;`

### ValidationResult Conflict Resolution

For files that need to work with both FluentValidation and DataAnnotations ValidationResult types (such as ValidationExtensions.cs), use a type alias:

```csharp
using FluentValidation.Results;
using ValidationResult = FluentValidation.Results.ValidationResult;
using Business.CustomerManagement.Sdk.Common;

namespace Business.CustomerManagement.Sdk.Common;

public static class ValidationExtensions
{
    public static IEnumerable<string> ToErrorMessages(this ValidationResult validationResult)
    {
        return validationResult.Errors.Select(error => error.ErrorMessage);
    }

    public static ApiResult<T> ToApiResult<T>(this ValidationResult validationResult, T? data = default)
    {
        // Implementation using the FluentValidation ValidationResult type
    }
}
```

## Generated Structure

```text
{Namespace}/
├── GlobalUsings.cs                      # Common using statements
├── {FeatureName}/
│   ├── Create{EntityName}Request.cs
│   ├── Create{EntityName}Response.cs
│   ├── Update{EntityName}Request.cs
│   ├── Update{EntityName}Response.cs
│   ├── Get{EntityName}Request.cs
│   ├── {EntityName}Response.cs
│   ├── {EntityName}ListResponse.cs
│   ├── {EntityName}Extensions.cs
│   ├── Create{EntityName}Validator.cs
│   ├── Update{EntityName}Validator.cs
│   └── {EntityName}Result.cs
└── Common/
    ├── ApiResult.cs
    └── ValidationExtensions.cs
```

**Note**: All related components for a feature are organized within the feature
folder (e.g., `Customers/`) to maintain vertical slice architecture. This keeps
related request/response models, validators, and extensions together rather than
separating them into technical layers.

## Code Generation Guidelines

### 1. Request Records

```csharp
// Only project-specific usings needed (GlobalUsings handles System.*, etc.)
using Business.CustomerManagement.Sdk.Common;

namespace Business.CustomerManagement.Sdk.{FeatureName};

public record Create{EntityName}Request
{
    // Properties from YAML attributes
    // Use appropriate C# types (string, int, DateTime, etc.)
    // Include XML documentation from YAML descriptions
    // DataAnnotation attributes available via GlobalUsings
    
    // REQUIRED PROPERTIES: Use 'required' keyword for non-nullable required fields
    // ✅ Good: public required string FirstName { get; init; }
    // ❌ Bad:  public string FirstName { get; init; } = string.Empty;
    
    // OPTIONAL PROPERTIES: Use nullable types for optional fields
    // ✅ Good: public string? Phone { get; init; }
    // ❌ Bad:  public string Phone { get; init; } = string.Empty;
}
```

#### Property Declaration Guidelines

- **Required Non-Nullable Fields**: Use `public required string PropertyName { get; init; }`
- **Optional Nullable Fields**: Use `public string? PropertyName { get; init; }`
- **Required Value Types**: Use `public required int PropertyName { get; init; }`
- **Optional Value Types**: Use `public int? PropertyName { get; init; }` or provide default values
- **Avoid `= string.Empty`**: Use `required` keyword instead for compile-time safety

### 2. Response Records

```csharp
using Business.CustomerManagement.Sdk.Common;

namespace Business.CustomerManagement.Sdk.{FeatureName};

public record {EntityName}Response
{
    // Include Id and all entity properties
    // Add audit fields (CreatedAt, UpdatedAt, etc.)
    // Include CreatedBy, UpdatedBy for user tracking
    // Add Version field for optimistic concurrency control
    // Use nullable types where appropriate
    // System types available via GlobalUsings
    
    // RESPONSE PROPERTIES: Use 'required' for guaranteed non-null properties
    // ✅ Good: public required Guid Id { get; init; }
    // ✅ Good: public required string Name { get; init; }
    // ✅ Good: public string? OptionalField { get; init; }
}
```

### 3. FluentValidation Validators

```csharp
using FluentValidation;
using Business.CustomerManagement.Sdk.Common;

namespace Business.CustomerManagement.Sdk.{FeatureName};

public class Create{EntityName}Validator : AbstractValidator<Create{EntityName}Request>
{
    public Create{EntityName}Validator()
    {
        // Rules based on YAML constraints
        // Business rules from YAML descriptions
        // Required field validation
        // Length and format validation
        
        // IMPORTANT: For Guid primary keys, enforce Version 7 UUID requirement
        // RuleFor(x => x.Id)
        //     .NotEmpty()
        //     .Must(BeVersion7Uuid)
        //     .WithMessage("Primary key must be a Version 7 UUID for optimal database performance");
    }
    
    /// <summary>
    /// Validates that a Guid is a Version 7 UUID for optimal database performance
    /// </summary>
    /// <param name="guid">The Guid to validate</param>
    /// <returns>True if the Guid is a valid Version 7 UUID, false otherwise</returns>
    private static bool BeVersion7Uuid(Guid guid)
    {
        if (guid == Guid.Empty) return false;
        
        // Version 7 UUIDs have version bits set to 0111 (7) in the 13th nibble
        var bytes = guid.ToByteArray();
        var versionByte = bytes[7]; // 8th byte contains version in upper nibble
        var version = (versionByte & 0xF0) >> 4;
        
        return version == 7;
    }
}
```

### 4. Extension Methods

```csharp
public static class {EntityName}Extensions
{
    public static {EntityName}Response ToResponse(this {EntityName} entity) => new()
    {
        // Map properties
    };

    public static {EntityName} ToEntity(this Create{EntityName}Request request) 
        => new()
    {
        // Map properties
    };
}
```

### 5. Result Pattern

```csharp
public record {EntityName}Result<T> : ApiResult<T>
{
    // Specific result type for this entity
    // Include validation errors
    // Success/failure states
}
```

## YAML Mapping Rules

### Attribute Type Mapping

- `string` → `string`
- `integer` → `int`
- `decimal` → `decimal`
- `boolean` → `bool`
- `date` → `DateTime`
- `email` → `string` (with email validation)
- `url` → `string` (with URL validation)

### Constraint Mapping

- `required: true` → C# `required` keyword + FluentValidation `.NotEmpty()`
- `required: false` → Nullable type (e.g., `string?`)
- `maxLength: X` → FluentValidation `.MaximumLength(X)`
- `minLength: X` → FluentValidation `.MinimumLength(X)`
- `pattern: "regex"` → FluentValidation `.Matches("regex")`

### Primary Key Validation Rules

When Guid fields are used as primary keys (typically Id fields), they MUST be validated as Version 7 UUIDs:

```csharp
// For Create requests with Guid primary keys
RuleFor(x => x.Id)
    .NotEmpty()
    .Must(BeVersion7Uuid)
    .WithMessage("Primary key must be a Version 7 UUID for optimal database performance and ordering");

// Version 7 UUID validation method (add to validator base or utility class)
private static bool BeVersion7Uuid(Guid guid)
{
    if (guid == Guid.Empty) return false;
    
    // Version 7 UUIDs have version bits set to 0111 (7) in the 13th nibble
    var bytes = guid.ToByteArray();
    var versionByte = bytes[7]; // 8th byte contains version in upper nibble
    var version = (versionByte & 0xF0) >> 4;
    
    return version == 7;
}
```

**Rationale for Version 7 UUIDs:**
- **Database Performance**: Time-ordered for better B-tree index performance
- **Natural Sorting**: Chronological ordering without additional timestamp fields
- **Reduced Fragmentation**: Sequential nature reduces database page fragmentation
- **Modern Standard**: Latest UUID specification (RFC 4122bis) recommended approach

### Required Field Implementation

For YAML fields marked as `required: true`:
```csharp
// ✅ Correct implementation
public required string RequiredField { get; init; }

// ❌ Avoid this pattern
public string RequiredField { get; init; } = string.Empty;
```

For YAML fields marked as `required: false` or no requirement specified:
```csharp
// ✅ Correct implementation
public string? OptionalField { get; init; }
```

### Enum Handling

- Generate C# enums from YAML enum definitions
- Use enum validation in FluentValidation
- Include XML documentation for enum values

## Security Considerations

- **Input Validation**: Validate all inputs using FluentValidation with comprehensive rules
- **Immutability**: Use record types for immutability and thread safety
- **Data Exposure**: Follow principle of least privilege in property exposure
- **XML Documentation**: Include comprehensive XML documentation for API consumers
- **Sanitization**: Implement input sanitization for string fields to prevent injection attacks
- **Length Limits**: Enforce maximum length constraints on all string properties
- **Type Safety**: Use strongly-typed enums instead of magic strings where possible
- **Nullable References**: Leverage nullable reference types to prevent null reference exceptions
- **UUID Version 7**: Enforce Version 7 UUIDs for primary keys to ensure optimal database performance, natural ordering, and prevent timing attacks through predictable ID generation

## Example Output

Given a `Customer.Type.yaml` with:

```yaml
name: Customer
summary: Represents a business customer entity
attributes:
  name:
    type: string
    required: true
    maxLength: 100
  email:
    type: email
    required: true
  phone:
    type: string
    maxLength: 20
  status:
    type: CustomerStatus
    required: true
```

Generate:

1. **GlobalUsings.cs** - Common namespace imports to reduce boilerplate
2. **CreateCustomerRequest.cs** - Input model for creating customers
3. **CustomerResponse.cs** - Output model for customer data
4. **CreateCustomerValidator.cs** - FluentValidation rules
5. **CustomerExtensions.cs** - Mapping methods
6. **Common/ApiResult.cs** - Base result pattern

## Output Format

Provide complete, compilable C# files with:

- **Project File**: `.csproj` targeting .NET 8.0 LTS with specified configuration
- **GlobalUsings.cs**: Common namespace imports to reduce boilerplate
- **Proper Namespaces**: Minimal file-specific using statements leveraging GlobalUsings
- **XML Documentation**: Comprehensive documentation for all public APIs
- **FluentValidation Rules**: Input validation based on YAML constraints and security best practices
- **Extension Methods**: Clean mapping methods without external dependencies
- **Security Controls**: Input sanitization, length limits, and type safety
- **Modern C# Features**: Records, nullable reference types, `required` keyword, pattern matching
- **Clean Code**: Readable code following .NET conventions and VSA principles
- **Version Control Ready**: Proper file organization and naming for source control

### Required Files per Feature

1. **{Feature}.csproj** - Project configuration with .NET 8.0 target
2. **GlobalUsings.cs** - Common namespace imports
4. **Common/ApiResult.cs** - Result pattern base class
5. **Common/ValidationExtensions.cs** - Validation utilities (IMPORTANT: Use `using ValidationResult = FluentValidation.Results.ValidationResult;` to resolve type ambiguity)
6. **{Feature}/{Entity}Request.cs** - Request models with validation attributes
7. **{Feature}/{Entity}Response.cs** - Response models inheriting audit fields
8. **{Feature}/{Entity}Validator.cs** - FluentValidation implementation
9. **{Feature}/{Entity}Extensions.cs** - Mapping methods
10. **{Feature}/{Entity}Result.cs** - Feature-specific result types

## Usage

This prompt template will be used with the Modeller MCP secure prompt
building system to generate production-ready SDK code from domain models.
